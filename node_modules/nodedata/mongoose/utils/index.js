"use strict";
const Mongoose = require('mongoose');
const entity_change_1 = require('../../core/enums/entity-change');
const CoreUtils = require('../../core/utils');
const Enumerable = require('linq');
const db_1 = require('../db');
const model_entity_1 = require('../../core/dynamic/model-entity');
const decorators_1 = require('../../core/constants/decorators');
const mongoose_1 = require("mongoose");
const constants_1 = require('../../core/constants');
var rn = require('random-number');
var gen = rn.generator({
    min: 0,
    max: 999999999,
    integer: true
});
function castToMongooseType(value, schemaType) {
    var newVal;
    switch (schemaType) {
        case Mongoose.Types.ObjectId:
            if (value instanceof Mongoose.Types.ObjectId) {
                newVal = value;
            }
            else if (typeof value === 'string') {
                newVal = new Mongoose.Types.ObjectId(value);
            }
            else {
                throw 'cannot cast to primary key type';
            }
            break;
        case String:
            if (typeof value === 'string') {
                newVal = value;
            }
            newVal = value.toString();
            break;
        case Number:
            if (typeof value === 'number') {
                newVal = value;
            }
            newVal = parseInt(value);
            if (isNaN(newVal)) {
                throw 'cannot cast to primary key type';
            }
            break;
        default:
            newVal = value;
            break;
    }
    return newVal;
}
exports.castToMongooseType = castToMongooseType;
function getPropertiesFromObject(changedObj) {
    return Enumerable.from(changedObj).select((x) => x.key).toArray();
}
exports.getPropertiesFromObject = getPropertiesFromObject;
/**
 * return json from mongoose object
 * @param result
 */
function toObject(result) {
    if (result instanceof Array) {
        return Enumerable.from(result).select((x) => x.toObject()).toArray();
    }
    return result ? result.toObject() : null;
}
exports.toObject = toObject;
/**
 * It creates list of properties to set/unset/push.
 * If array is passed, then for put whole array is replaced but for patch array is updated. For e.g.
 * Case 'put': Suppose there is an object {'ids':['1']}. On put {'ids':['2']}, it will result {'ids':['2']}.
 * Case 'patch': Suppose there is an object {'ids':['1']}. On patch {'ids':['2']}, it will result {'ids':['1', '2']}.
 * @param obj
 * @param type
 */
function getUpdatedProps(obj, type, jsonMapProp) {
    var push = {};
    var set = {};
    var unset = {};
    var s = false, u = false, p = false;
    let orginalDbEntity = obj.__dbEntity;
    for (var key in obj) {
        if (key === "__dbEntity") {
            continue;
        }
        let curValue = obj[key];
        if (curValue == undefined || curValue == null) {
            if (orginalDbEntity && curValue === orginalDbEntity[key]) {
                continue;
            }
            unset[key] = '';
            delete obj[key]; // make sure data should consistent for master collection with embedded entities
            u = true;
            continue;
        }
        if (orginalDbEntity && curValue instanceof Array && !curValue.length) {
            if (curValue instanceof Array && orginalDbEntity && orginalDbEntity[key].length == curValue.length) {
                continue;
            }
        }
        else {
            if (type == entity_change_1.EntityChange.patch && curValue instanceof Array) {
                push[key] = {
                    $each: curValue
                };
                p = true;
            }
            else {
                if (type == entity_change_1.EntityChange.patch && jsonMapProp && jsonMapProp.indexOf(key) >= 0) {
                    for (var j in curValue) {
                        set[key + '.' + j] = curValue[j];
                        s = true;
                    }
                }
                else if (!(curValue instanceof Function)) {
                    // do not set for not modified keys
                    // in case of object, use JSON.stringify to compare serialize object.
                    if (!Array.isArray(curValue) && curValue instanceof Object && orginalDbEntity) {
                        let serializeOrgObj = JSON.stringify(orginalDbEntity[key]);
                        let serializeCurObj = JSON.stringify(curValue);
                        if (serializeCurObj == serializeOrgObj) {
                            continue;
                        }
                    }
                    // in case of string, number, boolean etc. direct compare.
                    if (orginalDbEntity && curValue === orginalDbEntity[key]) {
                        continue;
                    }
                    set[key] = curValue;
                    s = true;
                }
            }
        }
    }
    var json = {};
    if (s) {
        json['$set'] = set;
    }
    if (u) {
        json['$unset'] = unset;
    }
    if (p) {
        json['$push'] = push;
    }
    return json;
}
exports.getUpdatedProps = getUpdatedProps;
function isPropertyUpdateRequired(changedProps, properties) {
    if (properties && properties.length > 0) {
        if (Enumerable.from(properties).any(x => changedProps.indexOf(x) > -1))
            return true;
    }
    if (!changedProps || changedProps.length == 0)
        return false;
    else if (!properties || properties.length == 0)
        return true;
    else {
        if (Enumerable.from(properties).any(x => changedProps.indexOf(x) > -1))
            return true;
        else
            return false;
    }
}
exports.isPropertyUpdateRequired = isPropertyUpdateRequired;
function getCurrentDBModel(schemaName) {
    var model = model_entity_1.getModel(schemaName);
    return db_1.getDbSpecifcModel(schemaName, model.schema);
}
exports.getCurrentDBModel = getCurrentDBModel;
function getMongoUpdatOperatorForRelation(meta) {
    var operator = "";
    switch (meta.decorator) {
        case decorators_1.Decorators.ONETOMANY:
            operator = '.$';
            break;
        case decorators_1.Decorators.MANYTOMANY:
            operator = '.$';
            break;
        case decorators_1.Decorators.MANYTOONE:
            operator = "";
            break;
        case decorators_1.Decorators.ONETOONE:
            operator = "";
            break;
    }
    return operator;
}
exports.getMongoUpdatOperatorForRelation = getMongoUpdatOperatorForRelation;
function isBasonOrStringType(obj) {
    if (!obj) {
        return undefined;
    }
    return !CoreUtils.isJSON(obj) || (CoreUtils.isJSON(obj) && obj instanceof mongoose_1.Types.ObjectId);
}
exports.isBasonOrStringType = isBasonOrStringType;
function getParentKey(modelName, prop, id) {
    let parent = {};
    parent[constants_1.ConstantKeys.collectionName] = modelName;
    parent[constants_1.ConstantKeys.property] = prop;
    parent[constants_1.ConstantKeys.parentId] = id;
    return parent;
}
exports.getParentKey = getParentKey;
function pushPropToArrayOrObject(prop, propVal, collecionObj, isFlat) {
    if (isFlat) {
        collecionObj[prop] = propVal;
    }
    else {
        collecionObj.push(propVal);
    }
}
exports.pushPropToArrayOrObject = pushPropToArrayOrObject;
/**
 * Autogenerate mongodb guid (ObjectId) for the autogenerated fields in the object
 * @param obj
 * throws TypeError if field type is not String, ObjectId or Object
 */
//export function autogenerateIdsForAutoFields(model: Mongoose.Model<any>, obj: any): void {
//    var fieldMetaArr = MetaUtils.getMetaData(getEntity(model.modelName), Decorators.FIELD);
//    if (!fieldMetaArr) {
//        return;
//    }
//    Enumerable.from(fieldMetaArr)
//        .where((keyVal) => keyVal && keyVal.params && (<IFieldParams>keyVal.params).autogenerated)
//        .forEach((keyVal) => {
//            var metaData = <MetaData>keyVal;
//            var objectId = new Mongoose.Types.ObjectId();
//            if (metaData.getType() === String) {
//                obj[metaData.propertyKey] = objectId.toHexString();
//            } else if (metaData.getType() === Mongoose.Types.ObjectId || metaData.getType() === Object) {
//                obj[metaData.propertyKey] = objectId;
//            } else {
//                winstonLog.logError(model.modelName + ': ' + metaData.propertyKey + ' - ' + 'Invalid autogenerated type');
//                throw TypeError(model.modelName + ': ' + metaData.propertyKey + ' - ' + 'Invalid autogenerated type');
//            }
//        });
//}
function autogenerateIds(model) {
    let primaryKey = '_id';
    let type = model.schema.paths[primaryKey].instance;
    switch (type) {
        case 'Number':
            return gen();
        default:
            let id = new Mongoose.Types.ObjectId();
            if (type == 'ObjectID') {
                return id;
            }
            else {
                return id.toString();
            }
    }
}
exports.autogenerateIds = autogenerateIds;
function getCastObjectId(model, id) {
    let primaryKey = '_id';
    let type = model.schema.paths[primaryKey].instance;
    if (type == 'ObjectID') {
        return new Mongoose.Types.ObjectId(id.toString());
    }
    else {
        return id;
    }
}
exports.getCastObjectId = getCastObjectId;

//# sourceMappingURL=index.js.map
