"use strict";
const Mongoose = require("mongoose");
const CoreUtils = require('../core/utils');
const winstonLog_1 = require('../logging/winstonLog');
const principalContext_1 = require('../security/auth/principalContext');
const Q = require('q');
// use main connection for pooling source
exports.mainConnection = {};
var allConnections = {};
var connectionOptions;
var emitters = new Array();
function connect() {
    let dbLoc = CoreUtils.config().Config.DbConnection;
    connectionOptions = CoreUtils.config().Config.DbConnectionOptions || {};
    getConnection(dbLoc, connectionOptions);
    exports.mainConnection = allConnections[dbLoc];
}
exports.connect = connect;
function getDbSpecifcModel(schemaName, schema) {
    var database = principalContext_1.PrincipalContext.get(CoreUtils.resources.userDatabase);
    if (database && allConnections[database]) {
        return allConnections[database].model(schemaName, schema);
    }
    else {
        return exports.mainConnection.model(schemaName, schema);
    }
}
exports.getDbSpecifcModel = getDbSpecifcModel;
function addEmitter(msg) {
    emitters.push(msg);
}
exports.addEmitter = addEmitter;
function removeEmitter(msg) {
    emitters = emitters.filter((mem) => { return mem != msg; });
}
exports.removeEmitter = removeEmitter;
function updateConnection(connectionString, connectionOption) {
    principalContext_1.PrincipalContext.save(CoreUtils.resources.userDatabase, connectionString);
    return getConnection(connectionString, connectionOption);
}
exports.updateConnection = updateConnection;
function getConnection(connectionString, connectionOption) {
    if (!connectionString)
        return Q.when(false);
    if (!allConnections[connectionString]) {
        var conn = Mongoose.createConnection(connectionString, defaultDomainOptions(connectionOption));
        allConnections[connectionString] = conn;
        return connectDataBase(conn, connectionString);
    }
    else {
        return Q.when(true);
    }
}
const emitMesseageToALL = (event, message) => {
    try {
        if (emitters && emitters.length) {
            emitters.forEach((emitter) => {
                emitter.emit(event, message);
            });
        }
    }
    catch (ex) { }
};
function connectDataBase(conn, connectionString) {
    let defer = Q.defer();
    conn.on('connecting', () => {
        winstonLog_1.winstonLog.logInfo(`trying to establish connection for ${connectionString}`);
    });
    conn.on('connected', () => {
        winstonLog_1.winstonLog.logInfo(`connection established successfully ${connectionString}`);
        defer.resolve(true);
        emitMesseageToALL('databaseconnected', conn);
    });
    conn.on('error', (err) => {
        winstonLog_1.winstonLog.logInfo(`connection to mongo failed for ${connectionString} with error ${err}`);
        defer.resolve(false);
        emitMesseageToALL('error', conn);
    });
    conn.on('disconnected', () => {
        winstonLog_1.winstonLog.logInfo(`connection closed successfully ${connectionString}`);
        defer.resolve(false);
        emitMesseageToALL('disconnected', conn);
    });
    return defer.promise;
}
function defaultDomainOptions(connectionOption) {
    if (!connectionOption) {
        connectionOption = {};
    }
    if (!connectionOption['server']) {
        connectionOption['server'] = {};
    }
    if (!connectionOption['replset']) {
        connectionOption['replset'] = {};
    }
    connectionOption['server']['domainsEnabled'] = true;
    connectionOption['replset']['domainsEnabled'] = true;
    return connectionOption;
}

//# sourceMappingURL=db.js.map
