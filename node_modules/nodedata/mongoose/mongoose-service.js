"use strict";
const Q = require('q');
const utils_1 = require("../core/metadata/utils");
const MongooseModel = require('./mongoose-model');
const model_entity_1 = require('../core/dynamic/model-entity');
const winstonLog_1 = require('../logging/winstonLog');
const Utils = require('./utils');
const utils = require('../mongoose/utils');
const principalContext_1 = require('../security/auth/principalContext');
const configUtil = require('../core/utils');
const db_1 = require('./db');
const constants_1 = require('../core/constants');
var hash = require('object-hash');
class MongooseService {
    constructor() {
    }
    updateWriteCount() {
        if (principalContext_1.PrincipalContext) {
            var count = principalContext_1.PrincipalContext.get('cacheCount');
            if (!count) {
                count = 0;
            }
            principalContext_1.PrincipalContext.save('cacheCount', ++count);
        }
    }
    bulkPost(repoPath, objArr, batchSize) {
        return MongooseModel.bulkPost(this.getModel(repoPath), objArr, batchSize);
    }
    bulkDel(repoPath, objArr) {
        return MongooseModel.bulkDel(this.getModel(repoPath), objArr).then(result => {
            objArr.forEach(x => this.deletEntityFromCache(repoPath, CacheConstants.idCache, x._id));
            return result;
        });
    }
    bulkPut(repoPath, objArr, batchSize, donotLoadChilds) {
        return MongooseModel.bulkPut(this.getModel(repoPath), objArr, batchSize, donotLoadChilds).then(results => {
            results.forEach((x) => {
                if (donotLoadChilds) {
                    x.__partialLoaded = true;
                }
                this.setEntityIntoCache(repoPath, CacheConstants.idCache, x._id, x);
            });
            return results;
        });
    }
    bulkPatch(repoPath, objArr) {
        return MongooseModel.bulkPatch(this.getModel(repoPath), objArr).then(results => {
            results.forEach(x => this.setEntityIntoCache(repoPath, CacheConstants.idCache, x._id, x));
            return results;
        });
    }
    bulkPutMany(repoPath, objIds, obj) {
        return MongooseModel.bulkPutMany(this.getModel(repoPath), objIds, obj).then(results => {
            //results && results.forEach((x: BaseModel) => {
            //    // in bulkPutMany we do not load egarLoading properties (children objects) so its partially loaded
            //    x.__partialLoaded = true;
            //    this.setEntityIntoCache(repoPath, CacheConstants.idCache, x._id, x);
            //});
            return results;
        });
    }
    findAll(repoPath) {
        return MongooseModel.findAll(this.getModel(repoPath));
    }
    findWhere(repoPath, query, selectedFields, queryOptions, toLoadChilds) {
        let hashEntity = hash(JSON.stringify(query));
        let cacheValueIds = this.getEntityFromCache(repoPath, CacheConstants.hashCache, hashEntity);
        if (cacheValueIds) {
            // get objects from cache only if previous findwhere does not cached with selectedFields
            let cachedValueResults = cacheValueIds.map(id => this.getEntityFromCache(repoPath, CacheConstants.idCache, id))
                .filter((x) => x && !x.__selectedFindWhere && !x.__partialLoaded);
            if (cacheValueIds.length === cachedValueResults.length) {
                console.log("cache hit success findWhere " + repoPath + " count " + cachedValueResults.length);
                this.updateWriteCount();
                return Q.when(cachedValueResults);
            }
        }
        return MongooseModel.findWhere(this.getModel(repoPath), query, selectedFields, queryOptions, toLoadChilds).then((results) => {
            results.forEach(result => {
                if (selectedFields && selectedFields.length > 0) {
                    result.__selectedFindWhere = true;
                }
                // if selected fields is empty or undefined and toLoadChilds is false, then set partialLoaded true
                if ((!selectedFields || selectedFields.length === 0) && toLoadChilds === false) {
                    result.__partialLoaded = true;
                }
                this.setEntityIntoCache(repoPath, CacheConstants.idCache, result._id, result);
            });
            this.setEntityIntoCache(repoPath, CacheConstants.hashCache, hashEntity, results.map(x => x._id));
            return results;
        });
    }
    countWhere(repoPath, query) {
        return MongooseModel.countWhere(this.getModel(repoPath), query);
    }
    distinctWhere(repoPath, query) {
        return MongooseModel.countWhere(this.getModel(repoPath), query);
    }
    findOne(repoPath, id, donotLoadChilds) {
        let cacheValue = this.getEntityFromCache(repoPath, CacheConstants.idCache, id);
        if (cacheValue && !cacheValue.__partialLoaded && !cacheValue.__selectedFindWhere) {
            console.log("cache hit success findone " + repoPath);
            this.updateWriteCount();
            return Q.when(cacheValue);
        }
        return MongooseModel.findOne(this.getModel(repoPath), id, donotLoadChilds).then((result) => {
            if (donotLoadChilds) {
                result.__partialLoaded = true;
            }
            this.setEntityIntoCache(repoPath, CacheConstants.idCache, id, result);
            return result;
        });
    }
    findByField(repoPath, fieldName, value) {
        return MongooseModel.findByField(this.getModel(repoPath), fieldName, value);
    }
    findMany(repoPath, ids, toLoadEmbeddedChilds) {
        // do not cache embedded objects
        if (!utils.isBasonOrStringType(ids[0])) {
            return Q.when(ids);
        }
        let chachedValues = [];
        let unChachedIds = [];
        ids.forEach(id => {
            let cacheValue = this.getEntityFromCache(repoPath, CacheConstants.idCache, id);
            if (cacheValue) {
                if (cacheValue.__selectedFindWhere) {
                    unChachedIds.push(id);
                    return;
                }
                if (toLoadEmbeddedChilds && cacheValue.__partialLoaded) {
                    unChachedIds.push(id);
                    return;
                }
                return chachedValues.push(cacheValue);
            }
            unChachedIds.push(id);
        });
        if (unChachedIds.length === 0) {
            return Q.when(chachedValues);
        }
        if (chachedValues && chachedValues.length) {
            console.log("cache hit success findMany " + repoPath + " count " + chachedValues.length);
            this.updateWriteCount();
        }
        return MongooseModel.findMany(this.getModel(repoPath), unChachedIds, toLoadEmbeddedChilds).then((results) => {
            results.forEach(result => {
                if (!toLoadEmbeddedChilds) {
                    result.__partialLoaded = true;
                }
                this.setEntityIntoCache(repoPath, CacheConstants.idCache, result._id, result);
            });
            return chachedValues.concat(results);
        });
    }
    findChild(repoPath, id, prop) {
        return MongooseModel.findChild(this.getModel(repoPath), id, prop);
    }
    /**
     * case 1: all new - create main item and child separately and embed if true
     * case 2: some new, some update - create main item and update/create child accordingly and embed if true
     * @param obj
     */
    post(repoPath, obj) {
        return MongooseModel.post(this.getModel(repoPath), obj);
    }
    put(repoPath, id, obj) {
        return MongooseModel.put(this.getModel(repoPath), id, obj).then(result => {
            this.setEntityIntoCache(repoPath, CacheConstants.idCache, id, result);
            return result;
        });
    }
    del(repoPath, id) {
        return MongooseModel.del(this.getModel(repoPath), id).then(result => {
            this.deletEntityFromCache(repoPath, CacheConstants.idCache, id);
            return result;
        });
    }
    patch(repoPath, id, obj) {
        return MongooseModel.patch(this.getModel(repoPath), id, obj).then(result => {
            this.setEntityIntoCache(repoPath, CacheConstants.idCache, id, result);
            return result;
        });
    }
    getModel(repoPath, dynamicName) {
        try {
            let model = Utils.getCurrentDBModel(model_entity_1.pathRepoMap[repoPath].schemaName);
            if (model && dynamicName) {
                var meta = utils_1.MetaUtils.getMetaData(model_entity_1.getEntity(model.modelName), constants_1.Decorators.DOCUMENT);
                if (meta && meta[0] && meta[0].params.dynamicName) {
                    model = db_1.getDbSpecifcModel(dynamicName, model.schema);
                }
            }
            return model;
        }
        catch (e) {
            winstonLog_1.winstonLog.logError(`Error in getMongooseModel ${e}`);
            throw e;
        }
    }
    getEntityFromCache(repoPath, param, id) {
        // entityCache->modelName_path->hashEntity->{key: valueObj}
        //                            ->idEntity->{key: valueObj}
        if (!configUtil.config().Config.isCacheEnabled) {
            return undefined;
        }
        let currentUser = principalContext_1.PrincipalContext.User;
        if (currentUser && currentUser.entityCache && currentUser.entityCache[repoPath] &&
            currentUser.entityCache[repoPath][param] && currentUser.entityCache[repoPath][param][id]) {
            // if current context view is changed then clear cache objects
            if (currentUser.cacheContext != currentUser.viewContext) {
                currentUser.cacheContext = currentUser.viewContext;
                currentUser.entityCache = [];
                return undefined;
            }
            return currentUser.entityCache[repoPath][param][id];
        }
        return undefined;
    }
    setEntityIntoCache(repoPath, entityType, id, value) {
        // entityCache->modelName_path->hashEntity->{key: valueObj}
        //                            ->idEntity->{key: valueObj}
        if (!configUtil.config().Config.isCacheEnabled) {
            return undefined;
        }
        let currentUser = principalContext_1.PrincipalContext.User;
        if (!currentUser) {
            currentUser = {};
            principalContext_1.PrincipalContext.User = currentUser;
        }
        if (!currentUser.entityCache) {
            currentUser.entityCache = {};
        }
        if (!currentUser.entityCache[repoPath]) {
            currentUser.entityCache[repoPath] = {};
        }
        if (!currentUser.entityCache[repoPath][entityType]) {
            currentUser.entityCache[repoPath][entityType] = {};
        }
        currentUser.entityCache[repoPath][entityType][id] = value;
    }
    deletEntityFromCache(repoPath, param, id) {
        if (!configUtil.config().Config.isCacheEnabled) {
            return undefined;
        }
        let currentUser = principalContext_1.PrincipalContext.User;
        if (currentUser && currentUser.entityCache && currentUser.entityCache[repoPath] &&
            currentUser.entityCache[repoPath][param][id]) {
            delete currentUser.entityCache[repoPath][param][id];
        }
    }
}
exports.MongooseService = MongooseService;
class CacheConstants {
}
CacheConstants.idCache = "idCache";
CacheConstants.hashCache = "hashCache";
exports.CacheConstants = CacheConstants;

//# sourceMappingURL=mongoose-service.js.map
