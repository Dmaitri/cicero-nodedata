"use strict";
const utils_1 = require("../metadata/utils");
const decorators_1 = require('../constants/decorators');
const decorator_type_1 = require('../enums/decorator-type');
var child_process = require('child_process');
const Enumerable = require('linq');
const winstonLog_1 = require('../../logging/winstonLog');
const workerParamsDto_1 = require("./interfaces/workerParamsDto");
const configUtil = require('../utils');
const principalContext_1 = require('../../security/auth/principalContext');
var fs = require('fs');
var defaultWorkerName = "core/decorators/worker.js";
var cls = require('continuation-local-storage');
var uuid = require('uuid');
var workerProcess = new Array();
var tasks = new Array();
//update from configuration
var _appRoot = process.cwd();
var _defaultWorker = 'worker.js';
var _defaultNumnberOfWorker = 1;
class WorkerProcess {
}
function Worker(params) {
    params = params || {};
    var session = principalContext_1.PrincipalContext.getSession();
    return function (target, propertyKey, descriptor) {
        console.log("target is: " + target + " propertyKey " + propertyKey + " descriptor is:  " + descriptor);
        utils_1.MetaUtils.addMetaData(target, {
            decorator: decorators_1.Decorators.WORKER,
            decoratorType: decorator_type_1.DecoratorType.METHOD,
            params: params,
            propertyKey: propertyKey
        });
        var originalMethod = descriptor.value;
        winstonLog_1.winstonLog.logDebug("Input params for worker:  " + params.workerParams);
        descriptor.value = executeWorkerHandler(params, target, propertyKey, originalMethod, decorators_1.Decorators.WORKER);
    };
}
exports.Worker = Worker;
// Add debug options
function getDebugOption(offset) {
    var execArgv = process.execArgv.slice(); //create args shallow copy
    var debugPort = process.debugPort + offset + 1;
    console.log("Debugging port:", debugPort);
    for (var i = 0; i < execArgv.length; i++) {
        var match = execArgv[i].match(/^(--debug|--debug-brk)(=\d+)?$/);
        if (match) {
            execArgv[i] = match[1] + '=' + debugPort;
            break;
        }
    }
    //var options = { env: process.env,  silent:false, execArgv: execArgv, cwd: targetProcessCwd };
    var options = { env: process.env, silent: false, execArgv: execArgv };
    return options;
}
function sendNextMessage(process, received) {
    if (received) {
        console.log('success message from Child Process: ' + received);
    }
    process.initialized = true;
    process.executing = null;
    if (tasks.length > 0) {
        var par = tasks.shift();
        par.processId = process.processId;
        process.executing = par;
        process.fork.send(par);
    }
}
function executeNextProcess(param) {
    var proc;
    var workerName = configUtil.config().Config.worker ? (_appRoot + '/' + configUtil.config().Config.worker) : (_appRoot + '/' + _defaultWorker);
    var thread = configUtil.config().Config.process ? configUtil.config().Config.process : _defaultNumnberOfWorker;
    if (thread > 0) {
        tasks.push(param);
        if (workerProcess.length < thread) {
            // create new process entry and spawn it
            proc = new WorkerProcess();
            proc.name = 'worker' + workerProcess.length + 1;
            var path = workerName;
            if (configUtil.config().Config.worker) {
                path = _appRoot + '/' + configUtil.config().Config.worker;
            }
            proc.fork = child_process.fork(path, [], getDebugOption(workerProcess.length));
            winstonLog_1.winstonLog.logInfo(`Forking a new child_process: path- ${path}, p id-${proc.fork.pid}  `);
            if (proc.fork.error == null) {
                proc.processId = proc.fork.pid;
                proc.executing = ({ initialize: true, processId: proc.processId });
                winstonLog_1.winstonLog.logInfo('Child process created with id: ' + proc.fork.pid);
                proc.fork.on('message', function (message) {
                    // notify service attached with this process
                    try {
                        var par = (message);
                        console.log('received message parsed successful');
                        var proc = Enumerable.from(workerProcess).firstOrDefault(x => x.processId == par.processId);
                        if (proc) {
                            sendNextMessage(proc, par);
                        }
                    }
                    catch (exc) {
                        console.log("failed message from Child Process: ");
                        console.log(exc);
                    }
                });
                proc.fork.on('error', function (err) {
                    winstonLog_1.winstonLog.logError('Error : ' + err);
                    // notify service attached with this process
                });
                proc.fork.on('close', function (code, signal) {
                    winstonLog_1.winstonLog.logInfo('Child process exited with code: ' + code + ' signal: ' + signal);
                    // notify service attached with this process
                });
                workerProcess.push(proc);
                winstonLog_1.winstonLog.logInfo('sending worker:' + proc.executing);
                proc.fork.send(proc.executing);
            }
            else {
                winstonLog_1.winstonLog.logError("Error during creating child Process: " + proc.fork.error);
            }
        }
        else {
            proc = Enumerable.from(workerProcess).firstOrDefault(x => !x.executing);
            if (proc) {
                sendNextMessage(proc, null);
            }
        }
    }
    else {
    }
    return process;
}
function executeWorkerHandler(params, target, propertyKey, originalMethod, type, noExecution) {
    return function () {
        if (utils_1.MetaUtils.childProcessId || !configUtil.config().Config.isMultiThreaded) {
            winstonLog_1.winstonLog.logInfo("Executing method from child Process with id: " + process.pid);
            return originalMethod.apply(this, arguments);
        }
        var targetObjectId;
        if (params.indexofArgumentForTargetObjectId)
            targetObjectId = arguments[params.indexofArgumentForTargetObjectId];
        if (params.indexofArgumentForTargetObject)
            targetObjectId = arguments[params.indexofArgumentForTargetObject]._id;
        var serviceName, servicemethodName, paramsArguments;
        var name = params.name;
        var workerParams = new workerParamsDto_1.workerParamsDto();
        if (params.workerParams == null) {
            winstonLog_1.winstonLog.logInfo("No Params sent with Worker()");
            var decorators = utils_1.MetaUtils.getMetaData(target);
            var dec = Enumerable.from(decorators).where(x => x.decorator == decorators_1.Decorators.SERVICE).firstOrDefault();
            if (dec) {
                workerParams.serviceName = dec.params.serviceName;
            }
            servicemethodName = propertyKey;
            workerParams.servicemethodName = servicemethodName;
            paramsArguments = arguments;
            workerParams.arguments = paramsArguments;
        }
        else {
            if (params.workerParams.serviceName != null && params.workerParams.serviceName != '') {
                serviceName = params.workerParams.serviceName;
                workerParams.serviceName = serviceName;
            }
            else {
                var decorators = utils_1.MetaUtils.getMetaData(target);
                var dec = Enumerable.from(decorators).where(x => x.decorator == decorators_1.Decorators.SERVICE).firstOrDefault();
                if (dec) {
                    workerParams.serviceName = dec.params.serviceName;
                }
                workerParams.serviceName = serviceName;
            }
            if (params.workerParams.servicemethodName != null && params.workerParams.servicemethodName != '') {
                servicemethodName = params.workerParams.servicemethodName;
                workerParams.servicemethodName = servicemethodName;
            }
            else {
                servicemethodName = propertyKey;
                workerParams.servicemethodName = servicemethodName;
            }
            if (params.workerParams.arguments != null && params.workerParams.arguments != '') {
                paramsArguments = params.workerParams.arguments;
                workerParams.arguments = paramsArguments;
            }
            else {
                paramsArguments = arguments;
                workerParams.arguments = paramsArguments;
            }
        }
        workerParams.arguments = Array.prototype.slice.call(workerParams.arguments);
        workerParams.arguments = workerParams.arguments.slice(0, originalMethod.length);
        //winstonLog.logInfo("Worker Params: " + workerParams);
        //PrincipalContext.save('workerParams', JSON.stringify(workerParams));
        workerParams.principalContext = principalContext_1.PrincipalContext.getAllKeyValues();
        let reqHeaders = workerParams.principalContext['req'].headers;
        if (workerParams.principalContext['req']) {
            delete workerParams.principalContext['req'];
            workerParams.principalContext['req'] = {};
            workerParams.principalContext['req'].headers = reqHeaders;
        }
        if (workerParams.principalContext['res']) {
            delete workerParams.principalContext['res'];
        }
        //console.log(`task will execute: Service Name ${workerParams.serviceName}, Method Name ${workerParams.servicemethodName}, Args ${workerParams.arguments}`);
        if (workerParams.serviceName != null) {
            workerParams.id = uuid.v4();
            if (!noExecution) {
                var proc = executeNextProcess(workerParams);
            }
        }
        return workerParams;
    };
}
exports.executeWorkerHandler = executeWorkerHandler;

//# sourceMappingURL=workerAssociation.js.map
