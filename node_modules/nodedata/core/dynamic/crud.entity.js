"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
const decorators_1 = require('../../mongoose/decorators');
const model_entity_1 = require("./model-entity");
const utils_1 = require("../metadata/utils");
const decorators_2 = require('../constants/decorators');
const transient_1 = require("../decorators/transient");
class CrudEntity {
    constructor() {
        ["put", "post", "delete", "patch"].forEach((prop) => {
            Object.defineProperty(this.__proto__, prop, {
                writable: false,
                value: CrudEntity.prototype[prop]
            });
        });
    }
    getCaller(trace) {
        for (let i = 2; i < trace.length; i++) {
            if (trace[i].getTypeName()
                && trace[i].getTypeName() != null
                && trace[i].getTypeName() != "wrappedPromise") {
                return trace[i].getTypeName();
            }
        }
        return undefined;
    }
    getRepo() {
        return this.getRepository();
    }
    getRepository() {
        let stack = require('stack-trace');
        let trace = stack.get();
        let caller = this.getCaller(trace);
        if (!caller)
            return undefined;
        // target.constructor.name
        let cachedModels = utils_1.MetaUtils.getMetaDataFromName(caller);
        utils_1.MetaUtils.getMetaDataFromName(caller);
        if (cachedModels && cachedModels.length) {
            return undefined;
        }
        if (this.constructor && this.constructor.name) {
            let c = model_entity_1.repoFromModel;
            var meta = utils_1.MetaUtils.getMetaData(this.constructor, decorators_2.Decorators.DOCUMENT);
            if (meta && meta[0]) {
                return model_entity_1.repoFromModel[meta[0].params.name];
            }
        }
        return undefined;
    }
    put() {
        if (!this.getRepository()) {
            return Q.reject("repository not found");
        }
        return this.getRepository().put(this._id, this);
    }
    post() {
        if (!this.getRepository()) {
            return Q.reject("repository not found");
        }
        return this.getRepository().post(this);
    }
    delete() {
        if (!this.getRepository()) {
            return Q.reject("repository not found");
        }
        return this.getRepository().delete(this._id);
    }
    patch() {
        if (!this.getRepository()) {
            return Q.reject("repository not found");
        }
        return this.getRepository().patch(this._id, this);
    }
}
__decorate([
    decorators_1.field({ primary: true, autogenerated: true }), 
    __metadata('design:type', Object)
], CrudEntity.prototype, "_id", void 0);
__decorate([
    decorators_1.field(),
    transient_1.transient(), 
    __metadata('design:type', Object)
], CrudEntity.prototype, "__dbEntity", void 0);
exports.CrudEntity = CrudEntity;
exports.put = () => {
    if (!this.getRepository()) {
        return Q.reject("repository not found");
    }
    return this.getRepository().put(this._id, this);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = CrudEntity;

//# sourceMappingURL=crud.entity.js.map
