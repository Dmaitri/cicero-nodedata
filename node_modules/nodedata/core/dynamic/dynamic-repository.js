"use strict";
const express = require("express");
var router = express.Router();
const Q = require('q');
const Utils = require('../utils');
const model_entity_1 = require('./model-entity');
const instance_service_1 = require('../services/instance-service');
const utils_1 = require("../metadata/utils");
const constants_1 = require('../constants');
const utils = require('../../mongoose/utils');
var modelNameRepoModelMap = {};
function GetRepositoryForName(name) {
    return modelNameRepoModelMap[name];
}
exports.GetRepositoryForName = GetRepositoryForName;
class DynamicRepository {
    //private modelRepo: any;
    initialize(repositoryPath, target, model, rootRepo) {
        //console.log(schema);
        this.path = repositoryPath;
        this.entity = target;
        this.rootLevelRep = rootRepo;
        if (target instanceof DynamicRepository) {
            target.rootLevelRep = rootRepo;
        }
        modelNameRepoModelMap[this.path] = this;
    }
    setMetaData(meta) {
        this.metaModel = meta;
    }
    getMetaData() {
        return this.metaModel;
    }
    setMessanger(msgner) {
        this.messenger = msgner;
        if (this.rootLevelRep) {
            this.rootLevelRep.setMessanger(msgner);
        }
    }
    getMessanger() {
        return this.messenger;
    }
    getEntity() {
        return model_entity_1.getEntity(model_entity_1.pathRepoMap[this.path].schemaName);
    }
    getModel(dynamicName) {
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).getModel(this.path, dynamicName);
    }
    getRootRepo() {
        return this.rootLevelRep;
    }
    bulkPost(objArr, batchSize) {
        var objs = [];
        objArr.forEach(x => {
            objs.push(instance_service_1.InstanceService.getInstance(this.getEntity(), null, x));
        });
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).bulkPost(this.path, objs, batchSize).then(result => {
            if (result && result.length > 0) {
                var res = [];
                result.forEach(x => {
                    res.push(instance_service_1.InstanceService.getObjectFromJson(this.getEntity(), x));
                });
                this.sendAllMessagesUsingMessenger(result);
                return res;
            }
            return result;
        });
    }
    bulkPut(objArr, batchSize, donotLoadChilds) {
        var objs = [];
        objArr.forEach(x => {
            objs.push(instance_service_1.InstanceService.getInstance(this.getEntity(), null, x));
        });
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).bulkPut(this.path, objs, batchSize, donotLoadChilds).then(result => {
            if (result && result.length > 0) {
                var res = [];
                result.forEach(x => {
                    res.push(instance_service_1.InstanceService.getObjectFromJson(this.getEntity(), x));
                });
                this.sendAllMessagesUsingMessenger(result);
                return res;
            }
            return result;
        });
    }
    sendAllMessagesUsingMessenger(entities) {
        if (!this.messenger) {
            return;
        }
        let messagesToSend = [];
        this.messenger.chekAndSend(this.path, entities);
        //entities.forEach(x => {           
        //    if (this.messenger) {
        //        messagesToSend.push();
        //    }
        //})
        //if (this.messenger && messagesToSend.length) {
        //    Q.allSettled(messagesToSend).then((sucess) => { console.log("send sucess") })
        //        .catch((err) => { console.log("error in sending message bulkPost", err) });
        //}
    }
    bulkPatch(objArr) {
        var objs = [];
        objArr.forEach(x => {
            objs.push(instance_service_1.InstanceService.getInstance(this.getEntity(), null, x));
        });
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).bulkPatch(this.path, objs).then(result => {
            if (result && result.length > 0) {
                var res = [];
                result.forEach(x => {
                    res.push(instance_service_1.InstanceService.getObjectFromJson(this.getEntity(), x));
                });
                this.sendAllMessagesUsingMessenger(result);
                return res;
            }
            return result;
        });
    }
    bulkPutMany(objIds, obj) {
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).bulkPutMany(this.path, objIds, obj).then(result => {
            if (result && result.length > 0) {
                var res = [];
                result.forEach(x => {
                    res.push(instance_service_1.InstanceService.getObjectFromJson(this.getEntity(), x));
                });
                this.sendAllMessagesUsingMessenger(result);
                return res;
            }
            return result;
        });
    }
    bulkDel(objArr) {
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).bulkDel(this.path, objArr);
    }
    modelName() {
        return this.path;
    }
    getEntityType() {
        return this.entity;
    }
    /**
     * Returns all the items in a collection
     */
    findAll() {
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).findAll(this.path).then(result => {
            if (result && result.length > 0) {
                var res = [];
                result.forEach(x => {
                    res.push(instance_service_1.InstanceService.getObjectFromJson(this.getEntity(), x));
                });
                return res;
            }
            return result;
        });
    }
    // public findWhere(query, selectedFields?: Array<any>): Q.Promise<any> {
    //     return Utils.entityService(pathRepoMap[this.path].modelType).findWhere(this.path, query, selectedFields).then(result => {
    //         if (result && result.length > 0) {
    //             var res = [];
    //             result.forEach(x => {
    //                 res.push(InstanceService.getObjectFromJson(this.getEntity(), x));
    //             });
    //             return res;
    //         }
    //         return result;
    //     });
    // }
    findWhere(query, selectedFields, queryOptions, toLoadChilds) {
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).findWhere(this.path, query, selectedFields, queryOptions, toLoadChilds).then(result => {
            if (result && result.length > 0) {
                var res = [];
                result.forEach(x => {
                    res.push(instance_service_1.InstanceService.getObjectFromJson(this.getEntity(), x));
                });
                return res;
            }
            return result;
        });
    }
    countWhere(query) {
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).countWhere(this.path, query).then(result => {
            return result;
        });
    }
    distinctWhere(query) {
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).distinctWhere(this.path, query).then(result => {
            return result;
        });
    }
    findOne(id, donotLoadChilds) {
        if (!utils.isBasonOrStringType(id)) {
            let result = id;
            return Q.when(instance_service_1.InstanceService.getObjectFromJson(this.getEntity(), result));
        }
        else {
            return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).findOne(this.path, id, donotLoadChilds).then(result => {
                if (result)
                    return instance_service_1.InstanceService.getObjectFromJson(this.getEntity(), result);
                return result;
            });
        }
    }
    findByField(fieldName, value) {
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).findByField(this.path, fieldName, value).then(result => {
            return instance_service_1.InstanceService.getObjectFromJson(this.getEntity(), result);
        });
    }
    findMany(ids, toLoadEmbeddedChilds) {
        if (!utils.isBasonOrStringType(ids[0])) {
            let result = ids;
            if (result && result.length > 0) {
                var res = [];
                result.forEach(x => {
                    res.push(instance_service_1.InstanceService.getObjectFromJson(this.getEntity(), x));
                });
                return Q.when(res);
            }
            return Q.when(result);
        }
        else {
            return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).findMany(this.path, ids, toLoadEmbeddedChilds).then(result => {
                if (result && result.length > 0) {
                    var res = [];
                    result.forEach(x => {
                        res.push(instance_service_1.InstanceService.getObjectFromJson(this.getEntity(), x));
                    });
                    return res;
                }
                return result;
            });
        }
    }
    findChild(id, prop) {
        //check if child model is diffrent from parent model (parent is doc and child is entity)
        //get child repo
        //call parent's find one and get the array of ids
        //return child repo.findmany (ids)
        //var childMeta:string = Utils.getRepoPathForChildIfDifferent(this.getEntity(), prop);
        //if (childMeta)
        //    return this.findOne(id).then(parent => {
        //        var chilldIds = parent[prop];
        //        if (!(chilldIds instanceof Array)) {
        //            chilldIds = [chilldIds];
        //        }
        //        return Utils.entityService(pathRepoMap[childMeta].modelType).findMany(childMeta,chilldIds);
        //    });
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).findChild(this.path, id, prop);
    }
    /**
     * case 1: all new - create main item and child separately and embed if true
     * case 2: some new, some update - create main item and update/create child accordingly and embed if true
     * @param obj
     */
    post(obj) {
        obj = instance_service_1.InstanceService.getInstance(this.getEntity(), null, obj);
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).post(this.path, obj).then(result => {
            if (result) {
                if (this.messenger) {
                    this.messenger.chekAndSend(this.path, result);
                }
            }
            return result;
        });
    }
    put(id, obj) {
        obj = instance_service_1.InstanceService.getInstance(this.getEntity(), id, obj);
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).put(this.path, id, obj).then(result => {
            let retVal = instance_service_1.InstanceService.getObjectFromJson(this.getEntity(), result);
            if (retVal) {
                if (this.messenger) {
                    this.messenger.chekAndSend(this.path, retVal);
                }
            }
            return retVal;
        });
    }
    delete(id) {
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).del(this.path, id);
    }
    patch(id, obj) {
        obj = instance_service_1.InstanceService.getInstance(this.getEntity(), id, obj);
        return Utils.entityService(model_entity_1.pathRepoMap[this.path].modelType).patch(this.path, id, obj).then(result => {
            let retVal = instance_service_1.InstanceService.getObjectFromJson(this.getEntity(), result);
            if (retVal) {
                if (this.messenger) {
                    this.messenger.chekAndSend(this.path, retVal);
                }
            }
            return retVal;
        });
    }
    /**
 * Below interceptor is used to add/remove some of the properties of model before sending it to client.
 * e.g. samplDocument = {"id" : "23","name" : "test","companyName" : "com"}, here if we don't want to pass companyName to client then it can be removed in this interceptor.
 */
    setRestResponse(obj) {
    }
    // This function should return the additional shard condition which will be added in all the query to avoid the queries for cross sharding
    getShardCondition() {
        return null;
    }
    castToPrimaryKey(id) {
        let primaryKey = '_id';
        let modelRepo = this.getEntityType();
        let decoratorFields = utils_1.MetaUtils.getMetaData(modelRepo.model.prototype, constants_1.Decorators.FIELD, primaryKey);
        if (decoratorFields == null) {
            decoratorFields = utils_1.MetaUtils.getMetaData(modelRepo.model.prototype, constants_1.Decorators.COLUMN, primaryKey);
        }
        if (decoratorFields && decoratorFields.params && decoratorFields.params.primaryKey && decoratorFields.getType() == Number) {
            return Number.parseInt(id);
        }
        return id;
    }
    onMessage(message) {
        return;
    }
}
exports.DynamicRepository = DynamicRepository;

//# sourceMappingURL=dynamic-repository.js.map
