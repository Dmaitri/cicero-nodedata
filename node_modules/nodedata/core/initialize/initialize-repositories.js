"use strict";
const utils_1 = require("../metadata/utils");
const Utils = require("../utils");
const dynamic_repository_1 = require('../dynamic/dynamic-repository');
const instance_service_1 = require('../services/instance-service');
var Config = Utils.config();
const constants_1 = require('../constants');
const decorator_type_1 = require('../enums/decorator-type');
const repositories_1 = require('../exports/repositories');
const Enumerable = require('linq');
const model_entity_1 = require('../dynamic/model-entity');
exports.mongooseNameSchemaMap = {};
var domain = require('domain');
var Messenger = require('../../mongoose/pubsub/messenger');
exports.repoMap = {};
class InitializeRepositories {
    constructor(server) {
        this.initializeRepo();
    }
    initializeRepo() {
        let self = this;
        let repositories = utils_1.MetaUtils.getMetaDataForDecorators([constants_1.Decorators.REPOSITORY]);
        Enumerable.from(repositories)
            .forEach((x) => {
            if (!x.metadata || !x.metadata.length) {
                return;
            }
            //let params = <IRepositoryParams>x.metadata[0].params;
            //let repositoryModel = MetaUtils.getMetaData(params.model.prototype, Decorators.DOCUMENT);
            //let schemaName = (<IDocumentParams>repositoryModel.params).name; // model name i.e. schema name
            //let schema = new DynamicSchema(params.model, schemaName);
            //let mongooseSchema = schema.getSchema();
            //mongooseSchemaMap[(<any>x.target).path] = { schema: mongooseSchema, name: schema.schemaName, fn: x.target };
            //mongooseNameSchemaMap[schema.schemaName] = mongooseSchema;
            let path = x.target.path;
            let repoParams = x.metadata[0].params;
            let model = repoParams.model;
            let newRepo;
            let rootRepo = new dynamic_repository_1.DynamicRepository();
            rootRepo.initialize(repoParams.path, x.target, model);
            if (x.target instanceof dynamic_repository_1.DynamicRepository) {
                newRepo = instance_service_1.InstanceService.getInstance(x.target, null, null);
            }
            else {
                newRepo = rootRepo;
            }
            newRepo.initialize(repoParams.path, x.target, model, rootRepo);
            exports.repoMap[path] = {
                fn: x.target,
                repo: newRepo
            };
            var metas = utils_1.MetaUtils.getMetaDataFromDecoratorType(model, decorator_type_1.DecoratorType.MODEL);
            if (metas && metas[0] && x.metadata[0]) {
                model_entity_1.repoFromModel[metas[0].params.name] = newRepo;
                newRepo.setMetaData(x.metadata[0]);
            }
            metas && metas[0] && (model_entity_1.repoFromModel[metas[0].params.name] = newRepo);
            //searchMetaUtils.registerToMongoosastic(repoMap[path].repo.getModel());
        });
        repositories_1.repositoryMap(exports.repoMap);
    }
}
exports.InitializeRepositories = InitializeRepositories;

//# sourceMappingURL=initialize-repositories.js.map
