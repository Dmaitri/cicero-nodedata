"use strict";
const utils_1 = require("../metadata/utils");
const Utils = require("../utils");
const decorators_1 = require('../constants/decorators');
var Config = Utils.config();
const constants_1 = require('../constants');
const repositories_1 = require('../exports/repositories');
const Enumerable = require('linq');
exports.mongooseNameSchemaMap = {};
const securityImpl = require('../dynamic/security-impl');
var domain = require('domain');
const messenger_1 = require('../../mongoose/pubsub/messenger');
const principalContext_1 = require('../../security/auth/principalContext');
const configUtils = require('../utils');
const initialize_repositories_1 = require('./initialize-repositories');
const uuidv4 = require('uuid/v4');
exports.allAutherizationRulesMap = {};
exports.channleMessangerMap = {};
const initialize_sockets_1 = require("./initialize-sockets");
class InitializeMessengers {
    constructor(server) {
        this.messenger = new messenger_1.Messenger({ retryInterval: 3000 });
        this.serverId = uuidv4();
        this.allAutherizationRulesMap = {};
        // name.role :{ role: string, accessmask: number, acl?: boolean }
        this.allSingleEmitterSettings = {}; // {repo.name} : Array<strings> roles
        this.clientSendCount = 0;
        this.startDateTime = undefined;
        this.executeFindMany = (client, repo, message, multiClients, collection) => {
            let self = this;
            let data = undefined;
            if (collection) {
                data = collection;
            }
            else {
                data = [message];
            }
            return repo.findMany(data).then((data) => {
                if (data && data.length) {
                    if (!self.startDateTime) {
                        self.startDateTime = new Date();
                    }
                    if (multiClients && multiClients.length) {
                        multiClients.forEach((client) => {
                            self.clientSendCount += data.length;
                            // console.log("########### socket send Count ######### ", self.clientSendCount++);
                            if ((self.clientSendCount % 1000) == 0) {
                                let recalcDateTime = new Date();
                                console.log("########### socket send Count ######### ", self.clientSendCount);
                                console.log("########### socket time taken ######### ", recalcDateTime.getTime() - self.startDateTime.getTime());
                            }
                            //client.emit(repo.modelName(), message)
                            data.forEach((subdata) => { client.emit(repo.modelName(), subdata); });
                        });
                    }
                    else {
                        self.clientSendCount += data.length;
                        // console.log("########### socket send Count ######### ", self.clientSendCount++);
                        if ((self.clientSendCount % 1000) == 0) {
                            console.log("########### socket send Count ######### ", self.clientSendCount);
                            let recalcDateTime = new Date();
                            console.log("########### socket time taken ######### ", recalcDateTime.getTime() - self.startDateTime.getTime());
                        }
                        //client.emit(repo.modelName(), message)
                        data.forEach((subdata) => { client.emit(repo.modelName(), subdata); });
                    }
                    return data;
                }
                return undefined;
            }).catch((error) => {
                //console.log("error in findmany socket emmitter", error);
                throw error;
            });
        };
        this.sendMessageToclient = (client, repo, message, multiClients, collection) => {
            if (client.handshake.query && client.handshake.query.curSession) {
                var d = domain.create();
                d.run(() => {
                    principalContext_1.PrincipalContext.User = securityImpl.getContextObjectFromSession(client.handshake.query.curSession);
                    //move to above 
                    if (securityImpl.isAuthorize({ headers: client.handshake.query }, repo, "findMany")) {
                        this.executeFindMany(client, repo, message, multiClients, collection);
                    }
                });
            }
        };
        this.getAllUsersForNotification = (entity) => {
            var services = utils_1.MetaUtils.getMetaDataForDecorators([constants_1.Decorators.SERVICE]);
            var service = Enumerable.from(services).where(x => x.metadata[0].params.serviceName == "authorizationService").select(x => x.metadata[0]).firstOrDefault();
            if (service) {
                return service.target.getAllUsersForNotification(entity);
            }
        };
        this.sendMessageOnRepo = (repo, message) => {
            try {
                if (repo && message) {
                    repo.onMessage(message);
                }
            }
            catch (ex) {
                console.log("error in on message", message);
            }
        };
        this.checkIfRepoForMessenger = (meta) => meta && (meta.params.exportType == decorators_1.ExportTypes.ALL ||
            ((((meta.params.exportType & decorators_1.ExportTypes.WS) == decorators_1.ExportTypes.WS) ||
                ((meta.params.exportType & decorators_1.ExportTypes.WS_BROAD_CAST) == decorators_1.ExportTypes.WS_BROAD_CAST) ||
                ((meta.params.exportType & decorators_1.ExportTypes.PUB_SUB) == decorators_1.ExportTypes.PUB_SUB))));
        this.messenger.sendMessageToclient = this.sendMessageToclient;
        this.messenger.getAllUsersForNotification = this.getAllUsersForNotification;
        this.getProcessService();
        exports.allAutherizationRules = (configUtils.securityConfig().SecurityConfig.ResourceAccess);
        exports.mainMessenger = this.messenger;
        if (exports.allAutherizationRules && exports.allAutherizationRules.length) {
            exports.allAutherizationRules.forEach((rule) => {
                let insideRulMap = {};
                if (rule && rule.acl && rule.acl.length) {
                    rule.acl.forEach((acl) => {
                        insideRulMap[acl.role] = acl;
                        if (acl.emitToSingleWorker) {
                            if (!this.allSingleEmitterSettings[rule.name]) {
                                this.allSingleEmitterSettings[rule.name] = [];
                            }
                            this.allSingleEmitterSettings[rule.name].push(acl.role);
                        }
                    });
                }
                this.allAutherizationRulesMap[rule.name] = insideRulMap;
            });
        }
        exports.allAutherizationRulesMap = this.allAutherizationRulesMap;
        this.initializeMessengersOnRepo(server);
    }
    schemaGenerator(schemaGenerator) {
        this._schemaGenerator = schemaGenerator;
    }
    getProcessService() {
        if (exports.workerProcessService) {
            return exports.workerProcessService;
        }
        var services = utils_1.MetaUtils.getMetaDataForDecorators([constants_1.Decorators.SERVICE]);
        var processService = Enumerable.from(services).where(x => x.metadata[0].params.serviceName == "workerprocessservice").select(x => x.metadata[0]).firstOrDefault();
        if (processService) {
            exports.workerProcessService = processService.target;
        }
        return exports.workerProcessService;
    }
    initializeMessengersOnRepo(server) {
        let self = this;
        let messenger = self.messenger;
        let messengerPool = new Array();
        messengerPool.push(messenger);
        for (let key in initialize_repositories_1.repoMap) {
            let repo = initialize_repositories_1.repoMap[key].repo;
            let meta = repo.getMetaData();
            if (self.checkIfRepoForMessenger(meta)) {
                let messenger = self.messenger;
                if (meta.params.dedicatedMessenger) {
                    messenger = new messenger_1.Messenger({ retryInterval: 3000, collectionName: key + "_message", cappedSize: meta.params.cappedSize });
                    messenger.sendMessageToclient = self.sendMessageToclient;
                    messenger.getAllUsersForNotification = self.getAllUsersForNotification;
                    if (meta.params.bufferBatchSize) {
                        messenger.batchSize = meta.params.bufferBatchSize;
                        messenger.run();
                    }
                    messengerPool.push(messenger);
                }
                if (self.allSingleEmitterSettings[key] && self.allSingleEmitterSettings[key].length) {
                    //console.log("over riding chekAndSend for ", key);
                    messenger.chekAndSend = (path, message) => {
                        return new Promise((resolve, reject) => {
                            //message modification can be done here
                            //example check connected workers as receipents and setting for single worker is set
                            //get role which need to recive single worker
                            let rolesForSinlgeEmitter = self.allSingleEmitterSettings[path];
                            if (rolesForSinlgeEmitter && rolesForSinlgeEmitter.length) {
                                //get random worker
                                let singleWorkerOnRole = undefined;
                                let singleRandomWorker = new Array();
                                rolesForSinlgeEmitter.forEach((role1) => {
                                    let singelWorker = self.getProcessService().getSingleRandomWoker(path, role1);
                                    if (singelWorker) {
                                        singleRandomWorker.push({ role: role1, serverId: singelWorker.serverId, workerId: singelWorker.workerId });
                                    }
                                });
                                if (singleRandomWorker.length) {
                                    singleWorkerOnRole = {};
                                    singleRandomWorker.forEach((singleWorker) => {
                                        singleWorkerOnRole[singleWorker.role + "_RC"] = singleWorker; //assuming RC channel
                                    });
                                    if (message instanceof Array) {
                                        message.forEach((msg) => { msg.singleWorkerOnRole = singleWorkerOnRole; });
                                    }
                                    else {
                                        message.singleWorkerOnRole = singleWorkerOnRole;
                                    }
                                }
                            }
                            messenger.send(path, message, function (err, data) {
                                resolve(true);
                                //console.log('Sent message');
                            });
                        });
                    };
                }
                exports.channleMessangerMap[key] = messenger;
                repo.setMessanger(messenger);
                messenger.subscribe(key, true);
                messenger.sendMessageOnRepo = this.sendMessageOnRepo;
            }
        }
        messengerPool.forEach((messenger) => {
            // connect() begins "tailing" the collection 
            messenger.onConnect(function () {
                // emits events for each new message on the channel 
                //console.log("messenger connected  starting registering repositories");
                for (let key in initialize_repositories_1.repoMap) {
                    let repo = initialize_repositories_1.repoMap[key].repo;
                    let meta = repo.getMetaData();
                    if (repo.getMessanger() != messenger) {
                        continue;
                    }
                    if (self.checkIfRepoForMessenger(meta)) {
                        messenger.on(key, function (data) {
                            //console.log("message received on ", key);
                            if (data.collection) {
                                initialize_sockets_1.messageBraodcastOnMessenger(repo, data.message, data.collection);
                            }
                            else {
                                initialize_sockets_1.messageBraodcastOnMessenger(repo, data);
                            }
                        });
                    }
                }
                if (messenger == exports.mainMessenger) {
                    initialize_sockets_1.socketConnector();
                }
            });
        });
        repositories_1.repositoryMap(initialize_repositories_1.repoMap);
    }
}
exports.InitializeMessengers = InitializeMessengers;

//# sourceMappingURL=initialize-messengers.js.map
