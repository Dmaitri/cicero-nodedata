"use strict";
const Utils = require("../utils");
const decorators_1 = require('../constants/decorators');
exports.mongooseNameSchemaMap = {};
const securityImpl = require('../dynamic/security-impl');
var domain = require('domain');
const principalContext_1 = require('../../security/auth/principalContext');
const initialize_repositories_1 = require('./initialize-repositories');
const queryOptions_1 = require('../interfaces/queryOptions');
const uuidv4 = require('uuid/v4');
const initialize_messengers_1 = require("./initialize-messengers");
class InitializeScokets {
    // name.role :{ role: string, accessmask: number, acl?: boolean }
    constructor(server) {
        this.socketClientholder = { socket: {}, clients: [], messenger: {} };
        this.socketChannelGroups = {}; // key is channel name and values array of groups
        this.sessionSocketIdMap = {}; //need to be handled the disconnection {userId}.{socket.id}:true
        this.io = undefined;
        this.serverId = uuidv4();
        this.checkIfRepoForMessenger = (meta) => meta && (meta.params.exportType == decorators_1.ExportTypes.ALL ||
            (this.io && (((meta.params.exportType & decorators_1.ExportTypes.WS) == decorators_1.ExportTypes.WS) ||
                ((meta.params.exportType & decorators_1.ExportTypes.WS_BROAD_CAST) == decorators_1.ExportTypes.WS_BROAD_CAST) ||
                ((meta.params.exportType & decorators_1.ExportTypes.PUB_SUB) == decorators_1.ExportTypes.PUB_SUB))));
        initialize_messengers_1.allAutherizationRules.forEach((rule) => {
            this.socketChannelGroups[rule.name] = {};
        });
        this.initializeSocketServer(server);
    }
    schemaGenerator(schemaGenerator) {
        this._schemaGenerator = schemaGenerator;
    }
    initializeSocketServer(server) {
        let self = this;
        let io = self.io;
        this.socketClientholder.socket = io;
        let joinNormalChannels = (socket) => {
            let session = socket.handshake.query.curSession;
            if (!session.userId) {
                return;
            }
            if (!self.sessionSocketIdMap[session.userId]) {
                self.sessionSocketIdMap[session.userId] = {};
            }
            self.sessionSocketIdMap[session.userId][socket.id] = true;
            if (socket.handshake.query && socket.handshake.query.applicableChannels
                && socket.handshake.query.applicableChannels.length) {
                socket.handshake.query.applicableChannels.forEach((room) => {
                    if (room && room.name) {
                        if (!self.socketChannelGroups[room.name]) {
                            self.socketChannelGroups[room.name] = {};
                        }
                    }
                });
            }
            if (socket.handshake.query && socket.handshake.query.channels) {
                let channelArr = socket.handshake.query.channels.split(",");
                if (channelArr && channelArr.length) {
                    channelArr.forEach((room) => {
                        //console.log("joined room ", room);
                        socket.join(room);
                    });
                }
            }
            return socket;
        };
        let joinRealiableChannels = (socket) => {
            if (socket.handshake.query && socket.handshake.query.broadcastChannels
                && socket.handshake.query.broadcastChannels.length) {
                socket.handshake.query.broadcastChannels.forEach((room) => {
                    if (room && room.name && room.group) {
                        if (socket.handshake.query && socket.handshake.query.reliableChannles) {
                            let channelArr = socket.handshake.query.reliableChannles.split(",");
                            if (channelArr.indexOf(room.name) > -1) {
                                //console.log("joined room group with reliable session", room.name + "_" + room.group + "_RC");
                                socket.join(room.name + "_" + room.group + "_RC");
                                if (!self.socketChannelGroups[room.name][room.group + "_RC"]) {
                                    self.socketChannelGroups[room.name][room.group + "_RC"] = true;
                                }
                                return;
                            }
                        }
                        //console.log("joined room group", room.name + "_" + room.group);
                        if (!self.socketChannelGroups[room.name][room.group]) {
                            self.socketChannelGroups[room.name][room.group] = false;
                        }
                        socket.join(room.name + "_" + room.group);
                    }
                    else if (room) {
                        //console.log("joined room ", room);
                        socket.join(room);
                    }
                });
            }
            return socket;
        };
        let createWorkerOnConnect = (socket) => {
            let session = socket.handshake.query.curSession;
            if (socket.handshake.query && socket.handshake.query.reliableChannles) {
                var Config = Utils.config();
                if (Config.Path && Config.Path.ackChannelName) {
                    socket.on(Config.Path.ackChannelName, function (data) {
                        //console.log("acknowledgement recieved", data);
                        // update last ask in session
                        securityImpl.updateSession({
                            netsessionid: socket.handshake.query.netsessionid,
                            channelName: data.message.channel,
                            lastack: new Date(data.message.timestamp),
                        }, session);
                    });
                }
                let channelArr = socket.handshake.query.reliableChannles.split(",");
                if (channelArr && channelArr.length) {
                    let newWorker = {
                        serverId: self.serverId, workerId: socket.id,
                        status: "connected", channels: channelArr, sessionId: session.sessionId, role: session.role
                    };
                    initialize_messengers_1.workerProcessService.createWorker(newWorker);
                }
            }
            return socket;
        };
        let sendPendingMesagesOnConnect = (socket) => {
            if (socket.handshake.query && socket.handshake.query.reliableChannles) {
                let channelArr = socket.handshake.query.reliableChannles.split(",");
                channelArr.forEach((rechannel) => {
                    if (socket.handshake.query.isAckRequired === "true" || socket.handshake.query.isAckRequired === true) {
                        securityImpl.getSessionLastAckForChannel(socket.handshake.query, rechannel).then((lastack) => {
                            if (lastack && initialize_messengers_1.channleMessangerMap && initialize_messengers_1.channleMessangerMap[rechannel]) {
                                //for each chnnel ask messeger the send an array of pending message
                                initialize_messengers_1.channleMessangerMap[rechannel].sendPendingMessage(rechannel, lastack, socket.id);
                            }
                        }).catch((error) => {
                            console.log("error in securityImpl.getSessionLastAckForChannel", error);
                        });
                    }
                    else {
                        securityImpl.getSessionLastTimeStampForChannel(socket.handshake.query, rechannel).then((lastemit) => {
                            if (lastemit && initialize_messengers_1.channleMessangerMap && initialize_messengers_1.channleMessangerMap[rechannel]) {
                                //for each chnnel ask messeger the send an array of pending message
                                initialize_messengers_1.channleMessangerMap[rechannel].sendPendingMessage(rechannel, lastemit, socket.id);
                            }
                        }).catch((error) => {
                            console.log("error in securityImpl.getSessionLastTimeStampForChannel", error);
                        });
                    }
                });
            }
            return socket;
        };
        let updateWorkerService = (socket) => {
            if (socket.handshake.query && socket.handshake.query.reliableChannles) {
                let channelArr = socket.handshake.query.reliableChannles.split(",");
                if (channelArr && channelArr.length) {
                    let newWorker = { serverId: self.serverId, workerId: socket.id, status: "disconnected", channels: channelArr };
                    initialize_messengers_1.workerProcessService.updateWorker(newWorker);
                }
            }
            return socket;
        };
        let updateSocketServer = (socket) => {
            if (socket.handshake.query.curSession && socket.handshake.query.curSession.userId) {
                let userId = socket.handshake.query.curSession.userId;
                delete self.sessionSocketIdMap[userId][socket.id];
                if (Object.keys(self.sessionSocketIdMap[userId]).length == 0) {
                    delete self.sessionSocketIdMap[userId];
                }
            }
            return socket;
        };
        //const compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)))
        const compose = (...functions) => data => functions.reduce((value, func) => func(value), data);
        //const compose = (...functions) => data =>
        //    functions.reduceRight((value, func) => func(value), data)
        let onSocketConnection = (socket) => { sendPendingMesagesOnConnect(createWorkerOnConnect(joinRealiableChannels(joinNormalChannels(socket)))); };
        //let onSocketConnection = (socket) => compose(joinNormalChannels , joinRealiableChannels , createWorkerOnConnect , sendPendingMesagesOnConnect)
        //let onSocketDisConnection = (socket) => compose(updateWorkerService , updateSocketServer)
        let onSocketDisConnection = (socket) => { updateWorkerService(updateSocketServer(socket)); };
        let arrOfReadAction = ["findAll", "findWhere", "countWhere", "distinctWhere", "findOne", "searchAll", "count"];
        let executefun = (parsedData, repo, socket) => {
            try {
                if (parsedData && parsedData.action && parsedData.message) {
                    if (securityImpl.isAuthorize(parsedData, repo, parsedData.action)) {
                        let resultpromise;
                        if (parsedData.action == "searchAll") {
                            parsedData.action = "findWhere";
                        }
                        if (parsedData.action == "count") {
                            parsedData.action = "countWhere";
                        }
                        if (parsedData.action == "findWhere" || parsedData.action == "countWhere") {
                            let resultquerydata = queryOptions_1.getQueryOptionsFromQuery(parsedData.message);
                            resultpromise = repo[parsedData.action](resultquerydata.queryObj, null, resultquerydata.options);
                        }
                        else {
                            resultpromise = repo[parsedData.action](parsedData.message);
                        }
                        if (arrOfReadAction.indexOf(parsedData.action) > -1) {
                            resultpromise.then((result) => socket.emit(repo.modelName(), result));
                        }
                    }
                }
            }
            catch (exceptio) {
            }
        };
        let onRepoMessageReceoved1 = (socket, data, repo) => {
            var d = domain.create();
            d.run(() => {
                //check if current session can be used
                if (data && data.headers && data.headers.netsessionid &&
                    socket.handshake.query.curSession && socket.handshake.query.curSession.sessionId &&
                    data.headers.netsessionid == socket.handshake.query.curSession.sessionId) {
                    principalContext_1.PrincipalContext.User = securityImpl.getContextObjectFromSession(socket.handshake.query.curSession);
                    executefun(data, repo, socket);
                    return;
                }
                let curExecuteFun = () => { executefun(data, repo, socket); };
                let result = (securityImpl.ensureLoggedIn()(data, undefined, curExecuteFun));
                if (result && result.catch) {
                    result.catch((err) => { console.log(err); });
                }
            });
        };
        let socketConector = () => {
            if (!io && server) {
                self.io = require('socket.io')(server, { 'transports': ['websocket', 'polling'] });
                io = self.io;
            }
            if (!io) {
                return;
            }
            io.on('connection', function (socket) {
                // this.socketClientholder.clients.push(client);
                //console.log('client connected', socket.id);
                if (socket.handshake.query) {
                    securityImpl.getSession(socket.handshake.query).then((session) => {
                        socket.handshake.query.curSession = session;
                        onSocketConnection(socket);
                    }).catch((error) => {
                        //console.log("error in getSession", error);
                    });
                }
                //emitt pending messages 
                //fetch last timestam of client for each reliable channel
                socket.on('disconnect', function () {
                    //console.log('client disconnected', socket.id);
                    onSocketDisConnection(socket);
                });
                for (let key in initialize_repositories_1.repoMap) {
                    let repo = initialize_repositories_1.repoMap[key].repo;
                    let meta = repo.getMetaData();
                    if (meta && ((meta.params.exportType & decorators_1.ExportTypes.WS) == decorators_1.ExportTypes.WS)) {
                        socket.on(key, function (data, callback) {
                            if (callback) {
                                callback("success");
                            }
                            onRepoMessageReceoved1(socket, data, repo);
                        });
                    }
                }
            });
        };
        exports.socketConnector = socketConector;
        let messageOnMessenger = (repo, message, collection) => {
            let key = repo.modelName();
            let messenger = repo.getMessanger();
            let meta = repo.getMetaData();
            if (!messenger) {
                return;
            }
            //console.log("message received on ", key);
            if ((meta.params.exportType & decorators_1.ExportTypes.PUB_SUB) == decorators_1.ExportTypes.PUB_SUB) {
                // messenger.sendMessageOnRepo(repo, message);
                if (collection && collection.length) {
                    collection.forEach((msg) => {
                        messenger.sendMessageOnRepo(repo, msg);
                    });
                }
                else {
                    messenger.sendMessageOnRepo(repo, message);
                }
            }
            if (!io) {
                return;
            }
            //handle if repo is completly broadcast
            let broadcastToAll = (castType) => {
                io.sockets.emit(key, message);
                let channelRoom = io.sockets.adapter.rooms[key];
                if (channelRoom) {
                    var roomclients = channelRoom.length;
                    //io.sockets.emit(key, message);
                    //io.to(key).emit(key, message);
                    //io.broadcast.to(key).emit(key, message);
                    console.log("WS_BROAD_CAST", { "channel": key, "no_of_broadcasts": roomclients });
                }
            };
            if (meta.params.broadCastType && meta.params.broadCastType == decorators_1.ExportTypes.WS_BROAD_CAST) {
                broadcastToAll("WS_BROAD_CAST");
                // io.to(key).emit(message);
                return;
            }
            // io.in(key).emit(key, message);
            //NO aACL define 
            if (!initialize_messengers_1.allAutherizationRulesMap[key]) {
                broadcastToAll("BROAD_CAST_NO_RULE");
                return;
            }
            let messageSendStatistics = {};
            let connectedClients = 0;
            let broadCastClients = 0;
            let reliableClients = 0;
            let individualClients = 0;
            let singelEmittClients = 0;
            //handle broad cast group ..acl ==false
            if (!self.socketChannelGroups[key]) {
                return;
            }
            let updateReliableChannelSettings = (client) => {
                if (!client) {
                    return;
                }
                if (!client.handshake) {
                    return;
                }
                if (!client.handshake.query) {
                    return;
                }
                if (!client.handshake.query.curSession) {
                    return;
                }
                reliableClients++;
                let query = client.handshake.query;
                let curSession = client.handshake.query.curSession;
                console.log("updating session timstamp for ", query && query.name);
                securityImpl.updateSession({
                    netsessionid: query.netsessionid,
                    channelName: key,
                    lastemit: messenger.lastMessageTimestamp,
                    status: 'active'
                }, curSession);
            };
            for (let channleGroup in self.socketChannelGroups[key]) {
                let isRealiableChannel = false;
                let groupName = key + "_" + channleGroup; //channleGroup is {role} , {role_RC} , key is repo name matchedorder_ROLE_ADMIN
                if (self.socketChannelGroups[key][channleGroup]) {
                    isRealiableChannel = self.socketChannelGroups[key][channleGroup];
                }
                let channelRoom = io.sockets.adapter.rooms[groupName];
                if (!channelRoom) {
                    continue;
                }
                var roomclients = channelRoom.sockets;
                let broadcastClients = new Array();
                let addAllclientsInRoom = () => {
                    if (isRealiableChannel &&
                        message.singleWorkerOnRole) {
                        return;
                    }
                    for (let channelId in roomclients) {
                        if (message.receiver && message.receiver != channelId) {
                            continue;
                        }
                        if (message.receiver) {
                            delete message.receiver;
                        }
                        let client = io.sockets.connected[channelId];
                        if (!client) {
                            continue;
                        }
                        broadcastClients.push(client);
                        broadCastClients++;
                        connectedClients++;
                        //under reliable channel
                        if (isRealiableChannel) {
                            updateReliableChannelSettings(client);
                        }
                    }
                };
                if (isRealiableChannel &&
                    message.singleWorkerOnRole && message.singleWorkerOnRole[channleGroup] &&
                    message.singleWorkerOnRole[channleGroup].serverId == self.serverId &&
                    roomclients[message.singleWorkerOnRole[channleGroup].workerId]) {
                    let client = io.sockets.connected[message.singleWorkerOnRole[channleGroup].workerId];
                    if (!client) {
                        continue;
                    }
                    //console.log("single emitter recieved on broadcasting", client.id)
                    broadcastClients.push(client);
                    broadCastClients++;
                    connectedClients++;
                    singelEmittClients++;
                    updateReliableChannelSettings(client);
                }
                else {
                    addAllclientsInRoom();
                }
                if (broadcastClients && broadcastClients.length) {
                    messenger.sendMessageToclient(broadcastClients[0], repo, message, broadcastClients, collection);
                }
            }
            //individual messages
            let individualUsers = messenger.getAllUsersForNotification(message);
            if (individualUsers && individualUsers.length) {
                individualUsers.forEach((user) => {
                    if (self.sessionSocketIdMap[user]) {
                        for (let channelId in self.sessionSocketIdMap[user]) {
                            let client = io.sockets.connected[channelId];
                            if (!client) {
                                continue;
                            }
                            //check if already broadcasted
                            if (client.handshake.query && client.handshake.query.broadcastChannels) {
                                let channelArr = client.handshake.query.broadcastChannels.filter((x) => { return x.name == key; });
                                if (channelArr && channelArr.length) {
                                    continue;
                                }
                            }
                            connectedClients++;
                            individualClients++;
                            messenger.sendMessageToclient(client, repo, message, undefined, collection);
                            if (client.handshake.query && client.handshake.query.reliableChannles) {
                                let channelArr = client.handshake.query.reliableChannles.split(",");
                                if (channelArr.indexOf(key) > -1) {
                                    updateReliableChannelSettings(client);
                                }
                            }
                        }
                    }
                });
            }
            messageSendStatistics.connectedClients = connectedClients;
            messageSendStatistics.broadCastClients = broadCastClients;
            messageSendStatistics.reliableClients = reliableClients;
            messageSendStatistics.individualClients = individualClients;
            messageSendStatistics.singelEmittClients = singelEmittClients;
            messageSendStatistics.channel = key;
            messageSendStatistics.id = message._id && message._id.toString();
            //console.log("pub-sub message sent ", messageSendStatistics);
        };
        exports.messageBraodcastOnMessenger = messageOnMessenger;
    }
}
exports.InitializeScokets = InitializeScokets;

//# sourceMappingURL=initialize-sockets.js.map
