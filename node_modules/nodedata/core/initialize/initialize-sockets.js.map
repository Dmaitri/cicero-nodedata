{"version":3,"sources":["core/initialize/initialize-sockets.ts"],"names":[],"mappings":"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","file":"core/initialize/initialize-sockets.js","sourcesContent":["import {MetaUtils} from \"../metadata/utils\";\nimport * as Utils from \"../utils\";\nimport * as mongooseUtils from '../../mongoose/utils';\nimport {MetaData} from '../metadata/metadata';\nimport {ExportTypes} from '../constants/decorators';\nimport {IDynamicRepository, DynamicRepository} from '../dynamic/dynamic-repository';\nimport {InstanceService} from '../services/instance-service';\nimport {ParamTypeCustom} from '../metadata/param-type-custom';\nimport {searchUtils} from \"../../search/elasticSearchUtils\";\n//var Config = Utils.config();\nimport {Decorators} from '../constants';\n\nimport {IRepositoryParams} from '../decorators/interfaces';\nimport {repositoryMap} from '../exports/repositories';\n\nimport {ISchemaGenerator} from '../interfaces/schema-generator';\nimport * as Enumerable from 'linq';\nimport {repoFromModel} from '../dynamic/model-entity';\n\nexport var mongooseNameSchemaMap: { [key: string]: any } = {};\n\nimport * as securityImpl from '../dynamic/security-impl';\nvar domain = require('domain');\nimport {inject} from '../../di/decorators/inject';\n\nimport {Messenger} from '../../mongoose/pubsub/messenger';\nimport {PrincipalContext} from '../../security/auth/principalContext';\nimport {Session} from  '../../models/session';\nimport * as configUtils from '../utils';\nimport {repoMap} from './initialize-repositories';\nimport {getQueryOptionsFromQuery} from '../interfaces/queryOptions';\nimport * as Q from 'q';\nconst uuidv4 = require('uuid/v4');\nimport {IWorkerProcessService} from \"../services/workerProcessService\";\nimport {IWorkerProcess} from \"../../models/IWorkerProcess\";\nimport {IAutherizationParam} from \"../../security/auth/autherizationParam\";\nimport {allAutherizationRules, allAutherizationRulesMap, workerProcessService, mainMessenger, channleMessangerMap} from \"./initialize-messengers\";\nexport var messageBraodcastOnMessenger: (repo: IDynamicRepository, message: any,collection?:any) => void;\nexport var socketConnector: () => void;\nexport class InitializeScokets {\n\n\n\n    private _schemaGenerator: ISchemaGenerator;\n    private socketClientholder: { socket: any, clients: Array<any>, messenger: any } = { socket: {}, clients: [], messenger: {} };\n    private socketChannelGroups: any = {}; // key is channel name and values array of groups\n    private sessionSocketIdMap = {}; //need to be handled the disconnection {userId}.{socket.id}:true\n    private socket: any;\n\n\n    private io:any = undefined;\n    \n\n    private serverId = uuidv4();\n    // name.role :{ role: string, accessmask: number, acl?: boolean }\n\n    constructor(server?: any) {\n\n        allAutherizationRules.forEach((rule) => {\n            this.socketChannelGroups[rule.name] = {};\n        });\n\n        this.initializeSocketServer(server);\n    }\n    public schemaGenerator(schemaGenerator: ISchemaGenerator) {\n        this._schemaGenerator = schemaGenerator;\n    }\n\n\n    private checkIfRepoForMessenger = (meta: MetaData): boolean =>\n        meta && (meta.params.exportType == ExportTypes.ALL ||\n            (this.io && (((meta.params.exportType & ExportTypes.WS) == ExportTypes.WS) ||\n                ((meta.params.exportType & ExportTypes.WS_BROAD_CAST) == ExportTypes.WS_BROAD_CAST) ||\n                ((meta.params.exportType & ExportTypes.PUB_SUB) == ExportTypes.PUB_SUB)))\n        )\n\n\n    private initializeSocketServer(server?: any) {\n        let self = this;\n\n\n\n        let io:any = self.io;\n        \n\n        this.socketClientholder.socket = io;\n\n\n        let joinNormalChannels = (socket):any => {\n            let session = socket.handshake.query.curSession;\n            if (!session.userId) { return; }\n            if (!self.sessionSocketIdMap[session.userId]) { self.sessionSocketIdMap[session.userId] = {}; }\n            self.sessionSocketIdMap[session.userId][socket.id] = true;\n            if (socket.handshake.query && socket.handshake.query.applicableChannels\n                && socket.handshake.query.applicableChannels.length) {\n                socket.handshake.query.applicableChannels.forEach((room) => {\n                    if (room && room.name) {\n                        if (!self.socketChannelGroups[room.name]) { self.socketChannelGroups[room.name] = {}; }\n                       \n                    }\n                });\n            }\n            if (socket.handshake.query && socket.handshake.query.channels) {\n                let channelArr: Array<string> = socket.handshake.query.channels.split(\",\");\n                if (channelArr && channelArr.length) {\n                    channelArr.forEach((room) => {\n                        //console.log(\"joined room \", room);\n                        socket.join(room);\n                    });\n                }\n            }\n            return socket;\n            \n        }\n\n        let joinRealiableChannels = (socket) => {\n            if (socket.handshake.query && socket.handshake.query.broadcastChannels\n                && socket.handshake.query.broadcastChannels.length) {\n                socket.handshake.query.broadcastChannels.forEach((room) => {\n                    if (room && room.name && room.group) {\n                        if (socket.handshake.query && socket.handshake.query.reliableChannles) {\n                            let channelArr: Array<string> = socket.handshake.query.reliableChannles.split(\",\");\n                            if (channelArr.indexOf(room.name) > -1) {\n                                //console.log(\"joined room group with reliable session\", room.name + \"_\" + room.group + \"_RC\");\n                                socket.join(room.name + \"_\" + room.group + \"_RC\");\n                                if (!self.socketChannelGroups[room.name][room.group + \"_RC\"]) { self.socketChannelGroups[room.name][room.group + \"_RC\"] = true }\n                                return;\n                            }\n                        }\n                        //console.log(\"joined room group\", room.name + \"_\" + room.group);\n                        if (!self.socketChannelGroups[room.name][room.group]) { self.socketChannelGroups[room.name][room.group] = false }\n                        socket.join(room.name + \"_\" + room.group);\n                    }\n                    else if (room) {\n                        //console.log(\"joined room \", room);\n                        socket.join(room);\n                    }\n                });\n            }\n            return socket;\n        }\n\n        let createWorkerOnConnect = (socket) => {\n            let session = socket.handshake.query.curSession;\n            if (socket.handshake.query && socket.handshake.query.reliableChannles) {\n                var Config = Utils.config();\n                if (Config.Path && Config.Path.ackChannelName) {\n                    socket.on(Config.Path.ackChannelName, function (data) {\n                        //console.log(\"acknowledgement recieved\", data);\n                        // update last ask in session\n                        securityImpl.updateSession({\n                            netsessionid: socket.handshake.query.netsessionid,\n                            channelName: data.message.channel,\n                            lastack: new Date(data.message.timestamp),\n                        }, session);\n                    })\n                }\n                let channelArr: Array<string> = socket.handshake.query.reliableChannles.split(\",\");\n                if (channelArr && channelArr.length) {\n                    let newWorker: IWorkerProcess = {\n                        serverId: self.serverId, workerId: socket.id,\n                        status: \"connected\", channels: channelArr, sessionId: session.sessionId, role: session.role\n                    };\n                    workerProcessService.createWorker(newWorker);\n                }\n            }\n            return socket;\n        }\n\n        let sendPendingMesagesOnConnect = (socket) => {\n            if (socket.handshake.query && socket.handshake.query.reliableChannles) {\n                let channelArr: Array<string> = socket.handshake.query.reliableChannles.split(\",\");\n\n                channelArr.forEach((rechannel) => {\n\n                    if (socket.handshake.query.isAckRequired === \"true\" || socket.handshake.query.isAckRequired === true) {\n                        securityImpl.getSessionLastAckForChannel(socket.handshake.query, rechannel).then((lastack) => {\n                            if (lastack && channleMessangerMap && channleMessangerMap[rechannel]) {\n                                //for each chnnel ask messeger the send an array of pending message\n\n                                channleMessangerMap[rechannel].sendPendingMessage(rechannel, lastack, socket.id);\n\n                                //use socket.emitt to send previous message\n                            }\n                        }).catch((error) => {\n                            console.log(\"error in securityImpl.getSessionLastAckForChannel\", error);\n                        });\n                    }\n                    else {\n                        securityImpl.getSessionLastTimeStampForChannel(socket.handshake.query, rechannel).then((lastemit) => {\n                            if (lastemit && channleMessangerMap && channleMessangerMap[rechannel]) {\n                                //for each chnnel ask messeger the send an array of pending message\n\n                                channleMessangerMap[rechannel].sendPendingMessage(rechannel, lastemit, socket.id);\n\n                                //use socket.emitt to send previous message\n                            }\n                        }).catch((error) => {\n                            console.log(\"error in securityImpl.getSessionLastTimeStampForChannel\", error);\n                        });\n                    }\n                }\n                )\n            }\n            return socket;\n        }\n\n        let updateWorkerService = (socket) => {\n            if (socket.handshake.query && socket.handshake.query.reliableChannles) {\n                let channelArr: Array<string> = socket.handshake.query.reliableChannles.split(\",\");\n                if (channelArr && channelArr.length) {\n                    let newWorker: IWorkerProcess = { serverId: self.serverId, workerId: socket.id, status: \"disconnected\", channels: channelArr };\n                    workerProcessService.updateWorker(newWorker);\n                }\n            }\n            return socket;\n        }\n        let updateSocketServer = (socket) => {\n            if (socket.handshake.query.curSession && socket.handshake.query.curSession.userId) {\n                let userId = socket.handshake.query.curSession.userId;\n                delete self.sessionSocketIdMap[userId][socket.id];\n                if (Object.keys(self.sessionSocketIdMap[userId]).length == 0) {\n                    delete self.sessionSocketIdMap[userId];\n                }\n\n            }\n            return socket;\n        }\n\n        //const compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)))\n        const compose = (...functions) => data =>\n            functions.reduce((value, func) => func(value), data)\n        //const compose = (...functions) => data =>\n        //    functions.reduceRight((value, func) => func(value), data)\n\n        let onSocketConnection = (socket) => { sendPendingMesagesOnConnect(createWorkerOnConnect(joinRealiableChannels(joinNormalChannels(socket)))) };\n        //let onSocketConnection = (socket) => compose(joinNormalChannels , joinRealiableChannels , createWorkerOnConnect , sendPendingMesagesOnConnect)\n\n        //let onSocketDisConnection = (socket) => compose(updateWorkerService , updateSocketServer)\n        let onSocketDisConnection = (socket) => { updateWorkerService(updateSocketServer(socket)) }\n\n        let arrOfReadAction = [\"findAll\", \"findWhere\", \"countWhere\", \"distinctWhere\", \"findOne\",\"searchAll\",\"count\"];\n        let executefun = (parsedData, repo,socket) => {\n            try {\n                if (parsedData && parsedData.action && parsedData.message) {\n                    if (securityImpl.isAuthorize(parsedData, repo, parsedData.action)) {\n                        let resultpromise: any;\n                        if (parsedData.action == \"searchAll\") {\n                            parsedData.action = \"findWhere\";\n                        }\n                        if (parsedData.action == \"count\") {\n                            parsedData.action = \"countWhere\";\n                        }\n                        if (parsedData.action == \"findWhere\" || parsedData.action == \"countWhere\") {\n                            let resultquerydata = getQueryOptionsFromQuery(parsedData.message);\n                            resultpromise = repo[parsedData.action](resultquerydata.queryObj, null, resultquerydata.options);\n                        } else {\n                             resultpromise = repo[parsedData.action](parsedData.message);\n                        }\n                        \n                        if (arrOfReadAction.indexOf(parsedData.action) > -1) {\n                            resultpromise.then((result) => socket.emit(repo.modelName(), result));\n                        }\n                    }\n                }\n            } catch (exceptio) {\n                //console.log(exceptio);\n            }\n        };\n\n        let onRepoMessageReceoved1 =  (socket,data,repo)=> {\n            var d = domain.create();\n            d.run(() => {\n                \n\n                    //check if current session can be used\n                    if (data && data.headers && data.headers.netsessionid &&\n                        socket.handshake.query.curSession && socket.handshake.query.curSession.sessionId && \n                        data.headers.netsessionid == socket.handshake.query.curSession.sessionId) {\n                        PrincipalContext.User = securityImpl.getContextObjectFromSession(socket.handshake.query.curSession);\n                        executefun(data, repo,socket);\n                        return\n                    }\n                     let curExecuteFun = () => { executefun(data, repo, socket); };\n                    let result = (<any>(securityImpl.ensureLoggedIn()(data, undefined, curExecuteFun)));\n                    if (result && result.catch) {\n                        result.catch((err) => { console.log(err); });\n                    }\n                \n                \n            });\n        };\n\n        let socketConector = () => {\n            if (!io && server) {\n                    self.io = require('socket.io')(server, { 'transports': ['websocket', 'polling'] });\n                    io = self.io;\n            }\n\n            if (!io) { return;}\n            io.on('connection',\n                function (socket) {\n                    // this.socketClientholder.clients.push(client);\n                    //console.log('client connected', socket.id);\n                    if (socket.handshake.query) {\n                        securityImpl.getSession(socket.handshake.query).then((session: Session) => {\n                            socket.handshake.query.curSession = session;\n\n                            onSocketConnection(socket);\n\n                        }).catch((error) => {\n                            //console.log(\"error in getSession\", error);\n                        });\n                    }\n\n                    //emitt pending messages \n                    //fetch last timestam of client for each reliable channel\n                    \n\n\n                    socket.on('disconnect', function () {\n                        //console.log('client disconnected', socket.id);\n                        onSocketDisConnection(socket);\n                    });\n\n                    for (let key in repoMap) {\n                        let repo = repoMap[key].repo;\n                        let meta: MetaData = repo.getMetaData();\n                        if (meta && ((meta.params.exportType & ExportTypes.WS) == ExportTypes.WS)) {\n                             socket.on(key, function (data, callback) {\n                                if (callback) {\n                                    callback(\"success\");\n                                }\n                                onRepoMessageReceoved1(socket, data, repo);\n                            })\n                               \n                        }\n\n                    }\n                   \n                }\n            )\n        }\n        socketConnector = socketConector;\n\n        let messageOnMessenger = (repo: IDynamicRepository, message: any,collection?:any) =>\n        {\n\n            let key = repo.modelName();\n            let messenger:Messenger = repo.getMessanger();\n\n            let meta: MetaData = repo.getMetaData();\n\n            if (!messenger) {\n                return;\n            }\n            //console.log(\"message received on \", key);\n\n            if ((meta.params.exportType & ExportTypes.PUB_SUB) == ExportTypes.PUB_SUB) {\n                // messenger.sendMessageOnRepo(repo, message);\n                if (collection && collection.length) {\n                    collection.forEach((msg) => {\n                        messenger.sendMessageOnRepo(repo, msg);\n                    });\n                } else {\n                    messenger.sendMessageOnRepo(repo, message);\n                }\n            }\n\n            if (!io) {\n                return;\n            }\n            //handle if repo is completly broadcast\n            let broadcastToAll = (castType: string) => {\n                io.sockets.emit(key, message);\n                let channelRoom:any = io.sockets.adapter.rooms[key];\n                if (channelRoom) {\n                    var roomclients = channelRoom.length;\n\n                    //io.sockets.emit(key, message);\n                    //io.to(key).emit(key, message);\n                    //io.broadcast.to(key).emit(key, message);\n\n                    console.log(\"WS_BROAD_CAST\", { \"channel\": key, \"no_of_broadcasts\": roomclients });\n                }\n            }\n\n            if (meta.params.broadCastType && meta.params.broadCastType == ExportTypes.WS_BROAD_CAST) {\n\n                broadcastToAll(\"WS_BROAD_CAST\");\n                // io.to(key).emit(message);\n                return;\n            }\n            // io.in(key).emit(key, message);\n            //NO aACL define \n            if (!allAutherizationRulesMap[key]) {\n                broadcastToAll(\"BROAD_CAST_NO_RULE\");\n                return;\n            }\n\n            let messageSendStatistics: any = {};\n            let connectedClients = 0;\n            let broadCastClients = 0;\n            let reliableClients = 0;\n            let individualClients = 0;\n            let singelEmittClients = 0;\n\n\n            //handle broad cast group ..acl ==false\n\n            if (!self.socketChannelGroups[key]) {\n                return;\n            }\n\n            let updateReliableChannelSettings = (client) => {\n                if (!client) { return; }\n                if (!client.handshake) { return; }\n                if (!client.handshake.query) { return; }\n                if (!client.handshake.query.curSession) { return; }\n                reliableClients++;\n                let query = client.handshake.query;\n                let curSession = client.handshake.query.curSession;\n                console.log(\"updating session timstamp for \", query && query.name);\n                securityImpl.updateSession({\n                    netsessionid: query.netsessionid,\n                    channelName: key,\n                    lastemit: messenger.lastMessageTimestamp,\n                    status: 'active'\n                }, curSession);\n            }\n\n            for (let channleGroup in self.socketChannelGroups[key]) {\n                let isRealiableChannel = false;\n                let groupName = key + \"_\" + channleGroup; //channleGroup is {role} , {role_RC} , key is repo name matchedorder_ROLE_ADMIN\n                if (self.socketChannelGroups[key][channleGroup]) {\n                    isRealiableChannel = self.socketChannelGroups[key][channleGroup];\n                    //groupName += \"_RC\";\n\n\n                }\n\n\n                let channelRoom = io.sockets.adapter.rooms[groupName];\n                if (!channelRoom) {\n                    continue;\n                }\n                var roomclients = channelRoom.sockets;\n\n\n                let broadcastClients: Array<any> = new Array<any>();\n\n\n                let addAllclientsInRoom = () => {\n                    if (isRealiableChannel &&\n                        message.singleWorkerOnRole) {\n                        return;\n                    }\n\n                    for (let channelId in roomclients) {\n\n\n                        if (message.receiver && message.receiver != channelId) {\n                            continue;\n                        }\n\n                        if (message.receiver) {\n                            delete message.receiver;\n                        }\n\n\n                        let client = io.sockets.connected[channelId];\n                        if (!client) {\n                            continue;\n                        }\n                        broadcastClients.push(client);\n                        broadCastClients++\n                        connectedClients++;\n                        //under reliable channel\n\n                        if (isRealiableChannel) {\n                            updateReliableChannelSettings(client);\n                        }\n                    }\n\n                }\n\n                if (isRealiableChannel &&\n                    message.singleWorkerOnRole && message.singleWorkerOnRole[channleGroup] &&\n                    message.singleWorkerOnRole[channleGroup].serverId == self.serverId &&\n                    roomclients[message.singleWorkerOnRole[channleGroup].workerId]) {\n\n\n                    let client = io.sockets.connected[message.singleWorkerOnRole[channleGroup].workerId];\n                    if (!client) {\n                        continue;\n                    }\n\n                    //console.log(\"single emitter recieved on broadcasting\", client.id)\n                    broadcastClients.push(client);\n                    broadCastClients++\n                    connectedClients++;\n                    singelEmittClients++;\n                    updateReliableChannelSettings(client);\n                }\n                else {\n                    addAllclientsInRoom();\n                }\n                if (broadcastClients && broadcastClients.length) {\n                    messenger.sendMessageToclient(broadcastClients[0], repo, message, broadcastClients,collection);\n                }\n            }\n            //individual messages\n            let individualUsers: Array<string> = messenger.getAllUsersForNotification(message);\n            if (individualUsers && individualUsers.length) {\n                individualUsers.forEach((user: string) => {\n                    if (self.sessionSocketIdMap[user]) {\n                        for (let channelId in self.sessionSocketIdMap[user]) {\n\n                            let client = io.sockets.connected[channelId];\n                            if (!client) {\n                                continue;\n                            }\n\n                            //check if already broadcasted\n                            if (client.handshake.query && client.handshake.query.broadcastChannels) {\n                                let channelArr: Array<string> = client.handshake.query.broadcastChannels.filter((x) => { return x.name==key });\n                                if (channelArr && channelArr.length) {\n                                    continue;\n                                }\n                            }\n\n                            connectedClients++;\n                            individualClients++;\n                            messenger.sendMessageToclient(client, repo, message,undefined,collection);\n                            if (client.handshake.query && client.handshake.query.reliableChannles) {\n                                let channelArr: Array<string> = client.handshake.query.reliableChannles.split(\",\");\n                                if (channelArr.indexOf(key) > -1) {\n                                    updateReliableChannelSettings(client);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            messageSendStatistics.connectedClients = connectedClients;\n            messageSendStatistics.broadCastClients = broadCastClients;\n            messageSendStatistics.reliableClients = reliableClients;\n            messageSendStatistics.individualClients = individualClients;\n            messageSendStatistics.singelEmittClients = singelEmittClients;\n            messageSendStatistics.channel = key;\n            messageSendStatistics.id = message._id && message._id.toString();\n            //console.log(\"pub-sub message sent \", messageSendStatistics);\n        };\n\n        messageBraodcastOnMessenger = messageOnMessenger;\n\n        \n\n        \n    }\n}"],"sourceRoot":"/source/"}